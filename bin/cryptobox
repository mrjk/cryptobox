#!/bin/bash
# TEMPLATE_VERSION=2024-08-18

# Basic bash template for command/resource based CLI.
# Features:
# * Automatic command discovery and help generation
# * Logging and traces
# * Application dependency checker
# * Support for getopts
# * Return code support
# * Command executor with dry mode


# shellcheck disable=SC2155


set -euo pipefail

# App Global variable
# =================

# Global vars
APP_SCRIPT="${0##*/}"
APP_NAME="${APP_SCRIPT%.*}"

# Metadata vars
APP_AUTHOR="author"
APP_EMAIL="email@address.org"
APP_LICENSE="GPLv3"
APP_URL="https://github.com/$APP_AUTHOR/$APP_NAME"
APP_REPO="https://github.com/$APP_AUTHOR/$APP_NAME.git"
APP_GIT="git@github.com:$APP_AUTHOR/$APP_NAME.git"

APP_STATUS=alpha
APP_DATE="2024-08-01"
APP_VERSION=0.0.1

# App configuration
APP_LOG_SCALE="TRACE:DEBUG:RUN:INFO:DRY:HINT:NOTICE:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT"
#APP_DEPENDENCIES="column tree"

APP_DRY=${APP_DRY:-false}
APP_FORCE=${APP_FORCE:-false}
APP_LOG_LEVEL=INFO # DRY, DEBUG, TRACE

# Automatic vars
# set -x
APP_IS_INTERACTIVE=${APP_IS_INTERACTIVE:-$([ -t 0 ] && echo true || echo false)}
SCRIPT_REAL_PATH=$(realpath  "$0")
SCRIPT_REAL_DIR=$(cd -- "$(dirname -- "$SCRIPT_REAL_PATH")" &>/dev/null && pwd)
APP_REAL_NAME=$(basename "$SCRIPT_REAL_PATH")
# set +x

APP_CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/$APP_REAL_NAME

SCRIPT_LIB="${SCRIPT_REAL_DIR}/../lib"

# Load internal libs
# source "$SCRIPT_LIB/utils.sh"
# source "$SCRIPT_LIB/idents.sh"
# source "$SCRIPT_LIB/backends.sh"


source "$SCRIPT_LIB/lib_utils.sh"
source "$SCRIPT_LIB/lib_clish.sh"
source "$SCRIPT_LIB/lib_conf.sh"
source "$SCRIPT_LIB/lib_resources.sh"

source "$SCRIPT_LIB/cli_idents.sh"
source "$SCRIPT_LIB/cli_gitvault.sh"
source "$SCRIPT_LIB/cli_vault.sh"



# Init loaders
# =================

# Init loaders
# =================

# Init loaders
# =================


# Init app
cb_init_app() {

  # export PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
  export PROJECT_ROOT=$PWD
  [[ -d "$PROJECT_ROOT" ]] ||
    _die 1 "Can't find project root. Are you in a git repo ?"

  # Go to the root project
  cd "$PROJECT_ROOT"
  export APP_DATA_DIR="${PROJECT_ROOT}"

  export APP_IDENT_DIR="${APP_DATA_DIR}/identities"
  export APP_STORES_DIR="${APP_DATA_DIR}/stores"
  export APP_VAULTS_DIR="${APP_DATA_DIR}/vaults"
  export APP_SPOOL_DIR="${APP_DATA_DIR}/.spool"

  # Prepare config
  APP_CACHE_FILE="$APP_SPOOL_DIR/secret_hash.ini"
  APP_CONFIG_FILE="${APP_DATA_DIR}/cryptobox.ini"
  APP_CONFIG_FILE_HASH=$(hash_sum "__config__")
  APP_CONFIG_FILE_ENC="${APP_STORES_DIR}/${APP_CONFIG_FILE_HASH}.age"


}

# VALIDATED
cb_init_ident() {
  local ident_name=$1

  [[ -z "${APP_IDENT_NAME:-}" ]] || return 0

  export APP_IDENT_NAME=$ident_name
  export APP_IDENT_HASH=$(hash_sum "$ident_name")

  # Export identity file
  export APP_IDENT_FILE_ENC="${APP_IDENT_DIR}/${APP_IDENT_HASH}.age"
  export APP_IDENT_FILE_CLEAR="${APP_IDENT_DIR}/${APP_IDENT_HASH}.id"
  export APP_IDENT_PRIV_KEY=
  export APP_IDENT_PUB_KEY=

  # Export best ident file
  export APP_IDENT_FILE="${APP_IDENT_FILE_ENC}"
  export APP_IDENT_FILE_STATUS="encrypted"
  if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
    APP_IDENT_FILE="${APP_IDENT_FILE_CLEAR}"
    APP_IDENT_FILE_STATUS="clear"
  fi

  # User personal vault
  export APP_IDENT_VAULT_NAME="ident_$ident_name"
  export APP_IDENT_VAULT_HASH=$(hash_sum "$APP_IDENT_VAULT_NAME")
  export APP_IDENT_VAULT_FILE_ENC="${APP_STORES_DIR}/${APP_IDENT_VAULT_HASH}.age"

  # User best passowrd
  # export APP_IDENT_PASSWORD=$(keyring_get_best_secret "$APP_IDENT_NAME")

}

# Inject private user key password
cb_init_ident_pass() {

  [[ -z "${APP_IDENT_PRIV_KEY:-}" ]] || return 0
  local private_key=

  # Fetch secret from keyring
  private_key=$(keyring_get_best_secret "${APP_IDENT_NAME}")

  # Read private key in memory
  if [[ -z "$private_key" ]]; then
    if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
      private_key=$(cat "$APP_IDENT_FILE_CLEAR")
    elif [[ -f "$APP_IDENT_FILE_ENC" ]]; then
      private_key=$(
        age --decrypt \
          -o - "$APP_IDENT_FILE_ENC"
      )
    # else
    #   _log WARN "Could not find keypair for ident: $APP_IDENT_NAME"
    fi
  fi

  private_key=$(grep '^AGE-SECRET-KEY-' <<<"$private_key")
  [[ -n "$private_key" ]] ||
    _die 1 "Could not read user private key ..."

  APP_IDENT_PRIV_KEY=$private_key
  APP_IDENT_PUB_KEY=$(echo "$private_key" | age-keygen -y)

}



# Metadata config
# =================

cb_config_encrypt() {
  local dest_hash=$APP_CONFIG_FILE_HASH
  local _vaulted_file="${APP_STORES_DIR}/${dest_hash}.age"
  local vaulted_file=${1:-$_vaulted_file}


  [[ -f "$APP_CONFIG_FILE" ]] || _die 0 "Already encrypted"

  # local vaulted_file=${APP_STORES_DIR}/$dest_hash.age

  all_pub=$(lib_id_get_all_pub_keys)
  age_recipient_args=$(_age_build_recipients_args "$all_pub")

  [[ -n "$age_recipient_args" ]] || _die 1 "Could not build all recipients list"
  local ret=

  # Decrypt the current file, and get checksum
  local commited_content_hash=$(_age_decrypt_with_ident \
    --output - "$vaulted_file" \
    | hash_sum -
    )

  # Decrypt local config and get hash
  local curr_hash=$(cat "$APP_CONFIG_FILE" | hash_sum - )

  # Quit if nothing to do
  if [[ "$commited_content_hash" == "$curr_hash" ]] ; then
    _log INFO "No need to reencrypt config"
    return 0
  fi

  # shellcheck disable=SC2086
  _exec age --encrypt \
    $age_recipient_args \
    --armor \
    --output "$vaulted_file" "$APP_CONFIG_FILE" || \
      _die "Failed to encrypt file: $APP_CONFIG_FILE"


  _log INFO "Config updated in vault: $vaulted_file"

}

cb_config_decrypt() {
  local dest_hash=$APP_CONFIG_FILE_HASH
  local _vaulted_file="${APP_STORES_DIR}/${dest_hash}.age"
  local vaulted_file=${1:-$_vaulted_file}

  local dest=$APP_CONFIG_FILE
  local tmp_dst="${dest}.new"

  [[ ! -e "$tmp_dst" ]] || _exec rm "$tmp_dst"
  _age_decrypt_with_ident \
    --output "$tmp_dst" "$vaulted_file" || \
    _die "Failed to decrypt file: $vaulted_file"

  # Do the change ?
  local new_hash=$(cat "$tmp_dst" | hash_sum - )
  local curr_hash=$(cat "$dest" | hash_sum - )

  if [[ "$new_hash" == "$curr_hash" ]] ; then
      rm "$tmp_dst"
    _log INFO "Config did not changed"
    return 0
  fi


  if [[ -f "$dest" ]]; then

    local changes=$(diff -U 0 "$dest" "$tmp_dst" | tail -n+4)
    local checksum_excluded=$(grep -v 'checksum = ' <<<"$changes" )

  #   echo "RESULT1: |$changes|"
  #   echo "RESULT2: |$checksum_excluded|"
  # set +x
    local erase=true

    if [[ -z "$checksum_excluded" ]]; then
      _log INFO "Update only item hash in config, safe to overwrite config"
      erase=true
    else
      _log WARN "Configuration changed for: $dest"
      colordiff -u "$tmp_dst" "$dest"
      _log WARN "Configuration will be updated:"

      erase=false
      if ! $APP_FORCE; then
        _confirm \
          "Do you want to add these changes to config?" || \
          erase=true
      fi
    fi

    if $erase; then
      _exec mv "$tmp_dst" "$dest" 
      _log INFO "Update $dest config from upstream"
    else
      _log INFO "Keep $dest config from local"
      _exec rm "$tmp_dst"
    fi
  else
    _log INFO "Create new $dest config"
    _exec mv "$tmp_dst" "$dest" 
  fi
  
}


cb_sync (){
  local ident=$1
  cb_pull "$ident"

  if _is_git_diverged "main"; then
    cb_fix "$ident"
  fi

  cb_push "$ident"

  _log INFO "Repo is now fully synced"

}

cb_pull() {
  : ",Pull add commit and push"
  local ident=$1

  cb_init_ident "$ident"

  _log INFO "Start pull"

  # Update config
  git pull --ff
  cb_config_decrypt
  items_pull_opened "$ident"

  if _is_git_diverged "main"; then
  _log WARN "Remote branch changed from local branch, please run: '$APP_NAME fix $ident'"
  _log INFO "Partial pull with fork, please fix"

  else
  _log INFO "Pulled with success"

  fi

}


cb_push() {
  : ",Pull add commit and push"
  local ident=$1

  cb_init_ident "$ident"

  _log INFO "Start push"
  items_push_opened "$ident"
  cb_config_encrypt

  # Prepare push
  local ret=0

  if ! is_in_git_clean_stage "stores" \
    || ! is_in_git_clean_stage "identities" \
    ; then

    _exec git add stores identities

    _exec git commit --untracked-files=no -m 'update vault' stores identities
  fi
  _exec git push 2>/dev/null || \
    _die 1 "Failed to push, please try '$APP_NAME pull $ident' first!"

  _log INFO "Pushed with success"

}


cb_fix() {
  : ",Fix diverging remote branches"

  local ident=$1
  local local_br="main"
  local upstream_br="origin/main"
  local upstream_prefix=.merge

  if ! _is_git_diverged "$local_br"; then
    _log INFO "Nothing to fix, try '$APP_NAME pull $ident'"
    _die 0 "No need to fix cryptobox"
  fi

  cb_init_ident "$ident"


  _log INFO "Compare changes from upstream"
  local has_changes=false
  local config_changed=''
  local idents_changed=''
  local stores_changed=''

  for file in $(git diff --name-only  "$local_br" "$upstream_br"); do
    # echo CAHNGED FILE: $file

    has_changes=true

    local change=''
    if [[ "$file" == "stores/${APP_CONFIG_FILE_HASH}.age" ]]; then
      change=config
      config_changed=$file
    elif [[ "$file" == "stores/"* ]]; then
      change=store
      stores_changed="${stores_changed}:${file}"
    elif [[ "$file" == "identities/"* ]]; then
      change=ident
      idents_changed="${idents_changed}:${file}"
    fi
    echo "  Type of change: $change => $file"

  done


  _log INFO "Apply changes from upstream"
  local _old_store_dir=$APP_STORES_DIR
  export APP_STORES_DIR="$upstream_prefix/stores"


  git worktree add "$upstream_prefix" "$upstream_br"


  if [[ -n "$config_changed" ]]; then
    _log INFO "Updating from upstream config ..."

    local target_enc="${APP_CONFIG_FILE}.new.enc"
    git show  origin/main:$config_changed > "$target_enc"

    cb_config_decrypt "$target_enc"
    rm "$target_enc"
  fi

  if [[ -n "$idents_changed" ]]; then
    _log INFO "Updating from upstream idents ..."
    _die 1 "Ident update not implemented yet"
  fi


  if [[ -n "$stores_changed" ]]; then
    _log INFO "Updating from upstream stores ..."

    for store in ${stores_changed//:/ }; do
      needle=${store##*stores/}
      needle=${needle%%.age}
      store_name=$(item_name_from_hash "$needle")
      store_kind=$(item_kind "$store_name" )

      # echo "$store_kind"
      _log INFO "Updating $store_kind: $store_name"
      item_pull "$store_kind" "$store_name" || \
        _log WARN "Failed to pull vault: $store_name"
      echo 
    done
  fi

  _log INFO "Cleanup diverging branches"
  # set -x
  export APP_STORES_DIR=$_old_store_dir
  git worktree remove -f   .merge

  _exec git checkout "$upstream_br"
  _exec git branch -D "$local_br"
  _exec git checkout -b "$local_br"
  _exec git branch --set-upstream-to=$upstream_br "$local_br"
  # set +x


  _log INFO "Repo is now fixed :)"

}


# TOFIX
# =================


cb_lock (){
  # set -x
  cb_init_ident "$1"


  # Close secrets
  local mode='all'
  local kinds=${APP_ITEMS_KINDS}

  for kind in $kinds; do

    case "$mode" in
    all)
      for vault in $(item_ident_resources "$APP_IDENT_NAME" "$kind"); do
        # _log INFO "Opening vault: $vault"
        "lib_${kind}_lock" "$vault" "$APP_IDENT_NAME"
      done
      ;;
    user)
      if item_assert_exists "$kind" "$APP_IDENT_VAULT_NAME" ; then
        _log INFO "Locking user vault for: $APP_IDENT_NAME"
        "lib_${kind}_lock" "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
      fi
      ;;
    esac
  done


  # Close config
  cb_config_encrypt


}


cb_unlock(){
  cb_init_ident "$1"



  _log DEBUG "Unlock global config with ident: $APP_IDENT_NAME"

  # Decrypt metadata
  cb_config_decrypt

  # Open secrets
  local mode='all'
  local kinds=${APP_ITEMS_KINDS}

  for kind in $kinds; do

    case "$mode" in
    all)
      for vault in $(item_ident_resources "$APP_IDENT_NAME" "$kind"); do
        # _log INFO "Opening vault: $vault"
        "lib_${kind}_unlock" "$vault" "$APP_IDENT_NAME"
      done
      ;;
    user)
      if item_assert_exists "$kind" "$APP_IDENT_VAULT_NAME" ; then
        _log INFO "Unlocking user vault for: $APP_IDENT_NAME"
        "lib_${kind}_unlock" "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
      fi
      ;;
    esac
  done
}



# CLI General Commands
# =================

cli__conf() {
  : "[ls|add|set|rm|get],Update donfiguration"
  _dir_db "$@"
}

cli__lock() {
  : ",Lock all vaults"
  _log DEBUG "Lock all vaults and config"
  if [[ -z "${1:-}" ]]; then
    _die 1 "You must use an ident to unlock the vault"
  fi
  cb_lock "$@"
}

cli__unlock() {
  : "ID,Unlock config"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_unlock "$@"
}


cli__sync() {
  : ",Sync: pull and push"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_sync "$@"
}

cli__pull() {
  : ",Pull add commit and push"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_pull "$@"
}

cli__push() {
  : ",Pull add commit and push"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_push "$@"
}

cli__fix() {
  : ",Fix diverging remote branches"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_fix "$@"
}

# CLI encrypt/decrypt Commands
# =================

cli__decrypt() {
  : "FILE,Decrypt a file"
  local file=$1
  # cb_init_ident
  _age_decrypt_file "$file" "$2"
}

cli__encrypt() {
  : "FILE,Encrypt a file"
  local file=$1
  cb_init_ident
  _age_encrypt_file "$file" "$APP_USER_IDENTITY_FILE"
}




# Core App
# =================

# App initialization
cli_init() {
  # Useful shortcuts
  export VCS_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
  export SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
  export WORK_DIR=${VCS_DIR:-${SCRIPT_DIR:-$PWD}}
  export PWD_DIR=${PWD}
}

# Check if all required bin are available in PATH
cli_require() {
  local deps=${@:-${APP_DEPENDENCIES:-}}

  local prog=
  for prog in ${deps-}; do
    _check_bin "$prog" || {
      _die 2 "Can't find '$prog', please install it first"
    }
  done
}

# App help message
cli_usage() {
  cat <<EOF
${APP_NAME} is command line tool to manage secrets in git repos.

usage: ${APP_NAME} <COMMAND> <TARGET> [<ARGS>]
       ${APP_NAME} help
EOF
}

# Parse CLI options
cli_options() {
  while [[ -n "${1:-}" ]]; do
    # : "parse-opt-start"
    case "$1" in
    -h | --help)
      : ",Show this help message"
      args=("help" "$@")
      shift
      ;;
    -n | --dry)
      : ",Enable dry mode"
      _log INFO "Dry mode enabled"
      APP_DRY=true
      shift
      ;;
    -f | --force)
      : ",Enable force mode"
      _log INFO "Force mode enabled"
      APP_FORCE=true
      shift
      ;;
    -V | --version)
      : ",Show version"
      echo "$APP_VERSION"
      _die 0
      ;;
    -v | -vv | -vvv | --verbose)
      : "[LEVEL],Set verbosity level"
      if [[ "$1" == "-vv" ]]; then
        APP_LOG_LEVEL=DEBUG
      elif [[ "$1" == "-vvv" ]]; then
        APP_LOG_LEVEL=TRACE
      else
        [[ -n "${2:-}" ]] || _die 1 "Missing log level value"
        APP_LOG_LEVEL=$2
        shift 1
      fi
      shift 1
      _log INFO "Log level set to: $APP_LOG_LEVEL"
      ;;
    -*)
      _die 1 "Unknown option: $1"
      ;;
    *)
      args=("$@")
      shift $#

      # To enable greedy parsing
      # args+=( "$1" )
      # shift 1
      ;;
    esac
    # : "parse-opt-stop"
  done
}

cli() {
  # Init
  trap '_sh_trap_error $? ${LINENO} trap_exit 42' EXIT

  # Parse CLI flags
  clish_parse_opts cli "$@"
  set -- "${args[@]}"

  # Init app
  cli_init

  cb_init_app

  # Route commands before requirements
  local cmd=${1:-help}
  shift 1 || true
  case "$cmd" in
  -h | --help | help | h)
    clish_help cli
    _die 0
    ;;
  esac

  # Check requirements
  cli_require

  # Dispatch subcommand
  clish_dispatch cli__ "$cmd" "$@" ||
    _die $? "Command '$cmd' returned error: $?"
}

cli "${@}"
