#!/bin/bash
# TEMPLATE_VERSION=2024-08-18

# Basic bash template for command/resource based CLI.
# Features:
# * Automatic command discovery and help generation
# * Logging and traces
# * Application dependency checker
# * Support for getopts
# * Return code support
# * Command executor with dry mode


# shellcheck disable=SC2155


set -euo pipefail

# App Global variable
# =================

# Global vars
APP_SCRIPT="${0##*/}"
APP_NAME="${APP_SCRIPT%.*}"

# Metadata vars
APP_AUTHOR="author"
APP_EMAIL="email@address.org"
APP_LICENSE="GPLv3"
APP_URL="https://github.com/$APP_AUTHOR/$APP_NAME"
APP_REPO="https://github.com/$APP_AUTHOR/$APP_NAME.git"
APP_GIT="git@github.com:$APP_AUTHOR/$APP_NAME.git"

APP_STATUS=alpha
APP_DATE="2024-08-01"
APP_VERSION=0.0.1

# App configuration
APP_LOG_SCALE="TRACE:DEBUG:RUN:INFO:DRY:HINT:NOTICE:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT"
#APP_DEPENDENCIES="column tree"

APP_DRY=${APP_DRY:-false}
APP_FORCE=${APP_FORCE:-false}
APP_LOG_LEVEL=INFO # DRY, DEBUG, TRACE

# Automatic vars
APP_IS_INTERACTIVE=${APP_IS_INTERACTIVE:-$([ -t 0 ] && echo true || echo false)}
SCRIPT_REAL_PATH=$(realpath "$0")
SCRIPT_REAL_DIR=$(cd -- "$(dirname -- "$SCRIPT_REAL_PATH")" &>/dev/null && pwd)
APP_REAL_NAME=$(basename "$SCRIPT_REAL_PATH")

APP_CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/$APP_REAL_NAME

# CLI libraries
# =================

# Logging support, with levels
_log() {
  local lvl="${1:-DEBUG}"
  shift 1 || true

  # Check log level filter
  if [[ ! ":${APP_LOG_SCALE#*$APP_LOG_LEVEL:}:$APP_LOG_LEVEL:" =~ :"$lvl": ]]; then
    if [[ ! ":${APP_LOG_SCALE}" =~ :"$lvl": ]]; then
      >&2 printf "%s\n" "  BUG: Unknown log level: $lvl"
    else
      return 0
    fi
  fi

  local msg=${*}
  if [[ "$msg" == '-' ]]; then
    msg="$(cat -)"
  fi
  while read -r -u 3 line; do
    >&2 printf "%5s: %s\\n" "$lvl" "${line:- }"
  done 3<<<"$msg"
}

# Terminate all with error message and rc code
_die() {
  local rc=${1:-1}
  shift 1 || true
  local msg="${*:-}"
  local prefix=QUIT
  [[ "$rc" -eq 0 ]] || prefix=DIE
  if [[ -z "$msg" ]]; then
    [ "$rc" -ne 0 ] || exit 0
    _log "$prefix" "Program terminated with error: $rc"
  else
    _log "$prefix" "$msg"
  fi

  # Remove EXIT trap and exit nicely
  trap '' EXIT
  exit "$rc"
}

# Run command with dry mode support
_exec() {
  local cmd=("$@")
  if ${APP_DRY:-false}; then
    _log DRY "  | ${cmd[@]}"
  else
    _log RUN "  | ${cmd[@]}"
    "${cmd[@]}"
  fi
}

# Dump all application vars (debug)
# shellcheck disable=SC2120 # Argument is optional by default
_dump_vars() {
  local prefix=${1:-APP_}
  declare -p | grep " .. $prefix" >&2 || {
    >&2 _log WARN "No var starting with: $prefix"
  }
}

# Ensure a program is available
_check_bin() {
  local cmd cmds="${*:-}"
  for cmd in $cmds; do
    command -v "$1" >&/dev/null || return 1
  done
}

# Internal helper to show bash traces (debug)
# shellcheck disable=SC2120 # Argument is optional by default
_sh_trace() {
  local msg="${*}"

  (
    >&2 printf "%s\n" "TRACE: line, function, file"
    for i in {0..10}; do
      trace=$(caller "$i" 2>&1 || true)
      if [ -z "$trace" ]; then
        continue
      else
        printf "%s\n" "$trace"
      fi
    done | tac | head -n -1
    [ -z "$msg" ] || >&2 printf "%s\n" "TRACE: Bash trace: $msg"
  )
}

# Internal function to catch errors
# Usage: trap '_sh_trap_error $? ${LINENO} trap_exit 42' EXIT
_sh_trap_error() {
  local rc=$1
  [[ "$rc" -ne 0 ]] || return 0
  local line="$2"
  local msg="${3-}"
  local code="${4:-1}"
  set +x

  _log ERR "Uncatched bug:"
  _sh_trace # | _log TRACE -
  if [[ -n "$msg" ]]; then
    _log ERR "Error on or near line ${line}: ${msg}; got status ${rc}"
  else
    _log ERR "Error on or near line ${line}; got status ${rc}"
  fi
  exit "${code}"
}

# Extra libs
# =================

# Ask the user to confirm
_confirm() {
  local msg="Do you want to continue?"
  >&2 printf "%s" "${1:-$msg}"
  >&2 printf "%s" "([y]es or [N]o): "
  export REPLY=

  >&2 read -r REPLY
  case $(tr '[A-Z]' '[a-z]' <<<"$REPLY") in
  y | yes)
    # printf "%s\n" "true"
    return 0
    ;;
  *)
    # printf "%s\n" "false"
    return 1
    ;;
  esac
}

# Ask the user to input string
_input() {
  local msg="Please enter input:"
  local default=${2-}
  >&2 printf "%s" "${1:-$msg}${default:+ [$default]}: "
  >&2 read -r REPLY
  [[ -n "$REPLY" ]] || REPLY=${default}
  printf "%s\n" "$REPLY"
}

# Ask the user to input string
_input2() {
  local default=${1-}
  local msg=${2:-"Please enter input"}
  local status=true
  export REPLY=

  while $status; do
    >&2 printf "%s" "${msg}${default:+ [$default]}: "
    >&2 read -r REPLY
    [[ -n "$REPLY" ]] || REPLY=${default}
    status=false
  done

  # printf "%s\n" "$REPLY"
}

_input_pass() {
  local msg=${1:-"Please enter password"}
  local status=true
  export REPLY=

  while $status; do
    >&2 printf "%s" "${msg}: "
    >&2 read -s -r REPLY

    >&2 echo ""
    if [[ -z "$REPLY" ]]; then
      _log WARN "Empty password, please try again."
    else
      status=false
    fi
  done

}

# Transform yaml to json
_yaml2json() {
  python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(json.dumps(y))'
}

# CLI helpers
# =================

# Dispatch command
clish_dispatch() {
  local prefix=$1
  local cmd=${2-}
  shift 2 || true
  [ -n "$cmd" ] || _die 3 "Missing command name, please check usage"

  if [[ $(type -t "${prefix}${cmd}") == function ]]; then
    "${prefix}${cmd}" "$@"
  else
    _log ERROR "Unknown command for ${prefix%%_?}: $cmd"
    return 3
  fi
}

# Parse command options
# Called function must return an args array with remaining args
clish_parse_opts() {
  local func=$1
  shift
  clish_dispatch "$func" _options "$@"
}

# Read CLI options for a given function/command
# Options must be in a case statement and surounded by
# 'parse-opt-start' and 'parse-opt-stop' strings. Returns
# a list of value separated by ,. Fields are:
clish_help_options() {
  local func=$1
  local data=

  # Check where to look options function
  if declare -f "${func}_options" >/dev/null; then
    func="${func}_options"
    data=$(declare -f "$func")
    data=$(printf "%s\n%s\n" 'parse-opt-start' "$data")
  else
    data=$(declare -f "$func")
  fi

  # declare -f ${func} \
  echo "$data" | awk '/parse-opt-start/,/parse-opt-stop/ {print}' |
    grep --no-group-separator -A 1 -E '^ *--?[a-zA-Z0-9].*)$' |
    sed -E '/\)$/s@[ \)]@@g;s/.*: "//;s/";//' |
    xargs -n2 -d'\n' |
    sed 's/ /,/;/^$/d'
}

# List all available commands starting with prefix
clish_help_subcommands() {
  local prefix=${1:-cli__}
  declare -f |
    grep -E -A 2 '^'"$prefix"'[a-z0-9]*(__[a-z0-9]*)*? \(\)' |
    sed '/{/d;/--/d;s/'"$prefix"'//;s/ ()/,/;s/";$//;s/^  *: "//;' |
    xargs -n2 -d'\n' |
    sed 's/, */,/;s/__/ /g;/,,$/d'
}

# Show help message of a function
clish_help_msg() {
  local func=$1
  clish_dispatch "$func" _usage 2>/dev/null || true
}

# Show cli usage for a given command
clish_help() {
  : ",Show this help"
  local func=${1:-cli}
  local commands='' options='' message='' output=''

  # Help message
  message=$(clish_help_msg $func)

  # Fetch command options
  options=$(
    while IFS=, read -r flags meta desc _; do
      if [ -n "${flags:-}" ]; then
        printf "  %-16s  %-20s  %s\n" "$flags" "$meta" "$desc"
      fi
    done <<<"$(clish_help_options $func)"
  )

  # Fetch sub command informations
  commands=$(
    while IFS=, read -r flags meta desc _; do
      if [ -n "${flags:-}" ]; then
        printf "  %-16s  %-20s  %s\n" "$flags" "$meta" "$desc"
      fi
    done <<<"$(clish_help_subcommands ${func}__)"
  )

  # Display help message
  printf "%s\n" "${message:+$message}
${commands:+
commands:
$commands}
${options:+
options:
$options
}"

  # Append extra infos
  if ! [[ "$func" == *"_"* ]]; then
    cat <<EOF
info:
  author: $APP_AUTHOR ${APP_EMAIL:+<$APP_EMAIL>}
  version: ${APP_VERSION:-0.0.1}-${APP_STATUS:-beta}${APP_DATE:+ ($APP_DATE)}
  license: ${APP_LICENSE:-MIT}
EOF
  fi

}

# Low level helpers
# =================

# Ensure a directory exists
ensure_dir() {
  local target=$1

  [[ -d "$target" ]] || _exec mkdir -p "$target"

}

# Return relative path from project root
make_rel_path_from_root() {
  sed -E "s:^$PROJECT_ROOT/?::"
}

# VALIDATED
# Return hash of string
hash_sum() {
  local seed=$1
  if [[ "$seed" == '-' ]]; then
    sha256sum - | sed 's/ .*//'
  else
    echo -n "$seed" | sha256sum | sed 's/ .*//'
  fi

}

# Ensure a config is correctly patched
patch_file() {
  local file="$1"
  local key_name="$2"
  local content
  local delim_key=ssh_config
  content=$(cat -)

  # Prepare delimiters
  local start_delimiter="# --- Start: $APP_NAME $delim_key $key_name ---"
  local stop_delimiter="# --- Stop: $APP_NAME $delim_key $key_name ---"

  # Ensure destination exists
  if [[ ! -f "$file" ]]; then

    local parent=$(dirname "${file}")
    if [[ -z "$parent" ]] && [[ ! -d "$parent" ]]; then
      _log INFO "Create missing parent directory: $parent"
      ensure_dir "$parent"
    fi

    _log INFO "Create new empty file: $file"
    _exec touch "$file"
  fi

  # Create payload
  local payload="$start_delimiter
$content
$stop_delimiter"

  if grep -q "$start_delimiter" "$file" && grep -q "$stop_delimiter" "$file"; then

    # Delimiters exist, check if update is needed
    local current_content='' content_before='' content_after=''

    # Calculate line indexes
    local line_sof=1
    local line_start=$(grep -n "$start_delimiter" "$file" | cut -f1 -d: | head -n 1)
    local line_stop=$(grep -n "$stop_delimiter" "$file" | cut -f1 -d: | head -n 1)
    local line_eof=$(wc -l "$file" | cut -d' ' -f1)

    line_stop=$((line_stop + 1))
    current_content=$(sed -n "${line_start},${line_stop}p;" "$file")

    _log TRACE "Line separators: $line_sof -> $line_start -> $line_stop -> $line_eof"

    if [ "$current_content" != "$payload" ]; then
      # Update needed
      _log INFO "Update content of: $file"

      # Update content
      if ! $APP_DRY; then
        (
          if [[ "$line_start" -gt 1 ]]; then
            sed -n "1,${line_start}p;" "$file" | sed '$ d'
          fi
          echo "$payload"
          if [[ "$line_stop" -lt $line_eof ]]; then
            sed -n "${line_stop},\$p" "$file" #| sed '1 d'
          fi
        ) >"$file.tmp"
        mv "$file.tmp" "$file"
      else
        _log DRY "Update file: $file"
      fi

    else
      _log INFO "File '$file' is already correctly configured"
    fi
    set +x
  else

    # TOFIX: Insert before Host *
    # local line_start=$(grep -n "Host *" "$file" | cut -f1 -d: | head -n 1)

    # Delimiters don't exist, append to the end of the file
    _log INFO "Add to content to: $file"
    if ! $APP_DRY; then
      echo -e "\n$payload" >>"$file"
    else
      _log DRY "Update file: $file"
    fi
  fi
}

# DB Commands
# =================

# VALIDATED
_db() {
  local config=$1
  shift 1
  _log TRACE "Query db: git-db -s '$config' $@"
  git-db -s "$config" "$@" 2>/dev/null
}

# Ensure workspace is unlocked
_db_ensure_open() {
  if [[ ! -f "$APP_CONFIG_FILE" ]]; then

    if [[ ! -f "$APP_CONFIG_FILE_ENC" ]]; then
      _log INFO "Create a new config file: $APP_CONFIG_FILE"
      _exec git-db init "$APP_CONFIG_FILE" #2>/dev/null
    else
      _die 1 "You must unlock repo first!"
    fi
  fi
}

# VALIDATED
# Directory DB
_dir_db() {

  # TO BE REMOVED LATER
  # Ensure config is present
  if [[ ! -f "$APP_CONFIG_FILE" ]]; then

    if [[ ! -f "$APP_CONFIG_FILE_ENC" ]]; then
      _log INFO "Create a new config file: $APP_CONFIG_FILE"
      _exec git-db init "$APP_CONFIG_FILE" #2>/dev/null
    else
      _die 1 "You must unlock repo first!"
    fi

  fi

  # Call db backend
  local xtra_args=
  ${APP_DRY} && xtra_args='-n'
  _db "$APP_CONFIG_FILE" $xtra_args "$@"

}

# Transform db dump into vars.
# TOFIX: How it works with multilines ?
_db_to_vars() {
  sed -E "s/\./__/;s/\./__/;s/=/='/;s/$/'/;s/^/db__/"
}

# Git commands
# =====================

is_in_git() {
  local file=$1
  if git status --porcelain "$file" | grep -q '^?? '; then
    return 1
  fi
  return 0
}

is_in_git_clean_stage() {
  local file=$1
  local ret=$(git status --porcelain "$file")
  if [[ -z "$ret" ]]; then
    return 0
  elif grep -q '^A ' <<<"$ret"; then
    return 0
  fi
  return 1
}

ensure_file_in_git() {
  local file=$1

  if is_in_git_clean_stage "$file"; then
    _log DEBUG "File is already in git"
  else
    _log DEBUG "Add encrypted file into git"
    _exec git add "$file"
  fi
}

# Age commands
# =====================

# Return true if age encrypted
is_age_encrypted_file() {
  local file=$1
  local ret=1

  [[ -f "$file" ]] || return 1

  if grep -q "BEGIN AGE ENCRYPTED FILE-----" "$file"; then
    ret=0
  elif grep -q "age-encryption.org/v1" "$file"; then
    ret=0
  fi

  return $ret
}

# Passwordless decrypt
_age_decrypt_with_ident() {
  load_ident_password || return $?

  [[ -n "$APP_IDENT_PRIV_KEY" ]] || _die 1 "Missing ident private key"
  _log DEBUG "Decrypt with age and internal priv key"
  age --decrypt --identity <(echo "$APP_IDENT_PRIV_KEY") "$@"

}

# Encrypt a file with age
_age_encrypt_file() {
  local file=$1
  local recipient=$2

  local dest=${3:-$file}

  # shellcheck disable=SC2086
  cat "$file" | age --encrypt \
    --armor \
    --recipient ${recipient//,/ --recipient } \
    -o "$dest"
}

# Decrypt a file with age
_age_decrypt_file() {
  local file=$1
  local ident=$2
  local dest=${3:-$file}

  load_ident "$ident"

  ident=${ident:-$APP_USER_IDENTITY_CRYPT_TARGET}

  _exec _age_decrypt_with_ident -o "$dest" "$file"
}

_age_public_key_from_private_key() {
  local file=$1
  local priv_key='' pub_key=''

  priv_key=$(age --decrypt "$file" 2>/dev/null)
  echo "$priv_key" | age-keygen -y

}

# Transform a list of recipients in age args
_age_build_recipients_args() {
  local pub_keys=$@
  local ret=

  pub_keys=$(tr '\n' ' ' <<<"$pub_keys")
  for recipient in $pub_keys; do
    ret="${ret:+$ret }-r $recipient"
  done
  [[ -n "$ret" ]] || return 1
  printf "%s" "$ret"
}

# Internal helpers
# =================

make_default_ident() {
  local name=$1
  [[ -f "$APP_USER_IDENTITY_FILE" ]] || {
    _die 1 "No such identiry: $name"
  }
  echo "$name" >"$APP_CURR_ID_FILE"
}

assert_current_ident() {
  [[ -n "$APP_CURR_IDENT" ]] || _die 1 "You must setup an ident first"
}

lib_keyring_is_unlocked() {
  local closed=

  if ! command -v "secret-tool" &>/dev/null; then
    _log DEBUG "Keyring disabled: Missing 'secret-tool' command"
    return 1
  fi

  if command -v "busctl" &>/dev/null; then
    closed=$(
      busctl --user get-property org.freedesktop.secrets \
        /org/freedesktop/secrets/collection/login \
        org.freedesktop.Secret.Collection Locked |
        grep -o 'true\|false'
    )
  elif command -v "gdbus" &>/dev/null; then
    closed=$(
      gdbus call -e -d org.freedesktop.secrets \
        -o /org/freedesktop/secrets/collection/login \
        -m org.freedesktop.DBus.Properties.Get \
        org.freedesktop.Secret.Collection Locked |
        grep -o 'true\|false'
    )
  else
    _log INFO "Please install 'busctl' or 'gdbus' to query state of keyring"
    closed=false
  fi

  if [[ "$closed" == "false" ]]; then
    _log DEBUG "Keyring is available and open"
    return 0
  fi

  _log DEBUG "Keyring is not open"
  return 1
}

keyring_get_best_secret() {
  local ident=$1
  local live_secret=

  lib_keyring_is_unlocked || return 0

  if [[ "$APP_IDENT_FILE_STATUS" == "encrypted" ]]; then
    _log INFO "Using keyring password for ident: $ident"
    secret-tool lookup "${APP_NAME}-ident" "$ident" 2>/dev/null || true
  fi

}

ensure_file_encrypted() {
  local file=$1
  local recipient_name=${2:-$APP_CURR_IDENT}
  local recipient=$(get_recipiant_id "$recipient_name")

  if is_age_encrypted_file "$file"; then
    _log DEBUG "File is already encrypted"
  else
    _log INFO "Encrypt file: $file for $recipient_name"
    _exec _age_encrypt_file "$file" "$recipient"
  fi

}

ensure_file_in_gitattr() {
  local name=$1
  local suffix="filter=sops"
  local pattern="$name $suffix"
  if grep -q "^$pattern" "$APP_GITATTR_FILE" 2>/dev/null; then
    _log DEBUG "File is already in $APP_GITATTR_FILE"
    return 0
  fi
  _log INFO "Add file to .gitattributes: $file"

  if ${APP_DRY:-false}; then
    _log DRY "Update file: $APP_GITATTR_FILE"
  else
    _log INFO "Update file: $APP_GITATTR_FILE"
    echo "$pattern" >>"$APP_GITATTR_FILE"
  fi
}

# Directory management
# =================

lib_dir_add_ident() {
  _dir_db

}

# Return all age pubkeys
lib_dir_age_pubkeys() {
  _dir_db dump ident | grep age-pub= | sed -E 's/[a-zA-Z0-9\.-]*=//'
}

# Identity management (internal)
# =================

get_recipiant_id() {
  local name=$1

  local dest_inv="${APP_INV_DIR}/$name.pub"
  cat "$dest_inv"
}

get_id_file_of_ident() {
  local ident=$1

  local hash=
  hash=$(_dir_db get "ident.$ident.ident-hash")

  echo "$APP_IDENT_DIR/$hash.age"
}

# Load dump into shell
lib_id_as_vars() {
  # Reset env
  # shellcheck disable=SC2086
  unset ${!db_ident__*} || true

  # Load
  local db_exc=$(lib_id_dump | _db_to_vars)
  echo "$db_exc"
  eval "${db_exc}"

}

# Return all ident pub keys from directory
lib_id_get_all_pub_keys() {
  _dir_db dump |
    grep '^ident\.[a-zA-Z-]*\.age-pub=' |
    sed 's/.*=//'
}

# VALIDATED
# Dump all idents
lib_id_dump() {
  _dir_db dump | grep '^ident\.'
}

# VALIDATED
# List identities
lib_id_list() {
  lib_id_dump |
    grep 'email\|login' |
    sed 's/^ident\.//;s/\..*//' |
    sort -u
}

# VALIDATED
# Check if ident exists
lib_id_exists() {
  local id=$1
  grep -q "$id" <<<"$(lib_id_list)"
}

# Identity management (Public)
# =================

# VALIDATED
# Generate new encrypted id
lib_id_new_ident__age() {
  local ident=$1
  local priv_key= pub_key=

  # Ensure id does not already exists in config
  if lib_id_exists "$ident"; then
    _die 0 "Identity '$ident' already exists."
  fi

  # Load ident settings
  load_ident "$ident"

  # Check if destinayion already exists
  if [[ -f "$APP_IDENT_FILE_ENC" ]]; then
    _log INFO "A age secret ident file is already present in: $APP_IDENT_FILE_ENC"
    $APP_FORCE ||
      _confirm "Do you really want to override '${APP_IDENT_NAME}' existing identity ?" ||
      _die 1 "User aborted"
  fi

  # Create identity
  _log INFO "Create new age id: $APP_IDENT_NAME"
  priv_key="$(age-keygen)"

  # Save into dedicated file
  ensure_dir "$APP_IDENT_DIR"
  pub_key=$(echo "$priv_key" | age-keygen -y)
  if ! $APP_DRY; then
    echo "$priv_key" | age --passphrase -a >"$APP_IDENT_FILE_ENC"
  else
    _log DRY "Save generated keypair in: $APP_IDENT_FILE_ENC"
  fi

  # Save in DB
  _dir_db set "ident.$APP_IDENT_NAME.ident-hash" "$APP_IDENT_HASH"
  _dir_db set "ident.$APP_IDENT_NAME.age-pub" "$pub_key"

  _log INFO "New private encrypted identity file: $APP_IDENT_FILE_ENC"
}

# Remove identity
lib_id_rm_ident__age() {
  local ident=$1
  local changed=false

  load_ident "$ident"

  # Ensure id does exists in config
  if lib_id_exists "$APP_IDENT_NAME"; then
    $APP_FORCE ||
      _confirm "Do you really want to remove '${APP_IDENT_NAME}' identity ?" ||
      _die 1 "User aborted"
    changed=true
  fi

  # Look for key to remove
  _dir_db rms "ident.$APP_IDENT_NAME" --remove-section

  # Delete identification key
  for file in "$APP_IDENT_FILE_ENC" "$APP_IDENT_FILE_CLEAR"; do
    [[ ! -f "$file" ]] || {
      _log INFO "Remove identiry file: $file"
      _exec rm "$file"
      changed=true
    }
  done

  if $changed; then
    _log INFO "Identity '$APP_IDENT_NAME' has been removed"
  else
    _log INFO "Identity '$APP_IDENT_NAME' is already absent"
  fi
}

# Vault management (internal)
# =================

# List vault names in config
vault_list_names() {
  _dir_db dump "vault." |
    sed 's/^vault.//;s/\..*//' |
    sort -u
}

# List all vault that belong to ident
vault_list_names_for_id() {
  local ident=$1

  _dir_db dump "vault." |
    grep "=$ident$" |
    sed 's/^vault.//;s/\..*//' |
    sort -u
}

# List opened vaults
lib_vault_opened_names() {
  local vaults=$(vault_list_names)
  for name in $vaults; do
    [[ -d "$APP_VAULTS_DIR/$name" ]] && echo "$name"
  done
}

# Check if a vault exists
vault_assert_exists() {
  local name=$1
  vault_list_names | grep -q "^$name$"
  return $?
}

# Return all recipients ids for a given vault
vault_ident_names() {
  local vault_name=$1
  _dir_db get "vault.$vault_name.recipient" |
    sort -u
}

# Return age pub_keys from recipients
vault_recipients_age_args() {
  local vault_name=$1
  local idents=
  idents=$(vault_ident_names "$vault_name")

  local ret=
  for ident in $idents; do
    match=$(_dir_db get "ident.$ident.age-pub")
    if [[ -n "$match" ]]; then
      ret="${ret:+$ret }$match"
    else
      _log WARN "Impossible to get public key of ident: $ident"
    fi
  done

  [[ -n "$ret" ]] || return 1
  _age_build_recipients_args "$ret"
}

# Vault management (public)
# =================

# Create an new opened vault
lib_vault_new() {
  local vault_name=$1
  shift 1
  local idents=${@:-}
  local valid=false

  # Sanity check
  vault_assert_exists "$vault_name" &&
    _die 0 "Vault '$vault_name' already exists."
  [[ -n "$idents" ]] || _die 1 "Missing recipient(s)"
  for ident in $idents; do
    [[ -n "$ident" ]] || continue
    lib_id_exists "$ident" ||
      _die 1 "Ident '$ident' does not exists"
  done

  _log INFO "Create new vault '$vault_name' for: $idents"
  local vault_hash=$(hash_sum "$vault_name")

  # Save in DB
  _dir_db set "vault.$vault_name.store-hash" "$vault_hash"
  for ident in $idents; do
    [[ -n "$ident" ]] || continue
    _dir_db add "vault.$vault_name.recipient" "$ident"
    valid=true
  done

  if ! $valid; then
    _die 1 'Missing valid idents, abort !'
  fi

  # Create vault
  local vault_dest="$APP_VAULTS_DIR/$vault_name"
  ensure_dir "$vault_dest"
  echo "Hello world" >>"$vault_dest/README.md"

}

# Remove and delete vault
lib_vault_rm() {
  # set -x
  local vault_name=$1
  local changed=false

  # Build vars
  local vault_hash=$(_dir_db get "vault.$vault_name.store-hash")
  local vault_enc="$APP_STORES_DIR/$vault_hash.age"
  local vault_dir="$APP_VAULTS_DIR/$vault_name"

  # Sanity checks
  [[ -n "$vault_hash" ]] || _die 1 "Could not get vault store hash"

  # Clear encrypted file
  if [[ -f "$vault_enc" ]]; then
    _log INFO "Delete encrypted vault file: $vault_enc"
    rm "$vault_enc"
    changed=true
  fi

  # Clear opened dir
  if [[ -d "$vault_dir" ]]; then
    local erase=false

    if $APP_FORCE; then
      erase=true
    else
      erase=false
      _confirm \
        "Do you want to delete directory '$vault_dir' data ?" &&
        erase=true
    fi

    if $erase; then
      _log INFO "Delete local secret data in '$vault_dir'"
      _exec rm -rf "$vault_dir"
      changed=true
    else
      _log WARN "Local secret data in '$vault_dir' wont be deleted!"
    fi
  fi

  # Clear configuration
  if vault_assert_exists "$vault_name"; then
    _dir_db rms "vault.$vault_name"
    changed=true
  fi

  # report to user
  if $changed; then
    _log INFO "Vault '$vault_name' has been removed"
  else
    _log INFO "Vault '$vault_name' does not exists"
  fi
}

# Encrypt a vault into age file
lib_vault_push() {
  local vault_name=$1

  # Build vars
  _db_ensure_open
  local vault_hash=$(_dir_db get "vault.$vault_name.store-hash")
  local vault_enc="$APP_STORES_DIR/$vault_hash.age"
  local vault_dir="$APP_VAULTS_DIR/$vault_name"

  # Sanity checks
  [[ -d "$vault_dir" ]] || _die 0 "Vault '$vault_name' already closed/locked"
  [[ -n "$vault_hash" ]] || _die 1 "Could not get vault store hash"

  # Fetch recipients
  age_recipient_args=$(vault_recipients_age_args "$vault_name")
  [[ -n "$age_recipient_args" ]] || _die 1 "No vault identity matched for: $vault_name"

  # Encrypt
  ensure_dir "$APP_STORES_DIR"

  local content_checksum=$(tar -czf - -C "$vault_dir" . | hash_sum -)
  local old_checksum=$(_dir_db get "vault.$vault_name.checksum")

  local ret=0
  local changed="without changes"
  if [[ "$old_checksum" == "$content_checksum" ]]; then
    _log DEBUG "No changes in vault, not reencrypting"
  else
    changed="with changes"
    _log DEBUG "Changes detected in vault, rencrypting data"
    if ! $APP_DRY; then
      _dir_db set "vault.$vault_name.checksum" "$content_checksum"
      # shellcheck disable=SC2086
      tar -czf - -C "$vault_dir" . | age --encrypt --armor -output "$vault_enc" $age_recipient_args
      ret=$?
    else
      _log DRY "Update encrypted file: $vault_enc"
    fi
  fi

  _log INFO "Vault '$vault_name' updated successfully $changed."

}

# Push changes and clean
lib_vault_lock() {
  local vault_name=$1

  local ret=''
  lib_vault_push "$vault_name"
  ret=$?

  # Validate
  [[ "$ret" -eq "0" ]] ||
    _die "$ret" "Some errors happened, did not remove local data!"

  # Cleanup
  _exec rm -rf "$APP_VAULTS_DIR/$vault_name"
  _log INFO "Vault '$vault_name' closed successfully."

}

# Decrypt and open vault
lib_vault_unlock() {
  local vault_name=$1
  shift 1
  local ident=${@:-}

  # Build vars
  local vault_hash=
  vault_hash=$(_dir_db get "vault.$vault_name.store-hash")
  local vault_enc="$APP_STORES_DIR/$vault_hash.age"
  local vault_dir="$APP_VAULTS_DIR/$vault_name"

  # Sanity check
  vault_assert_exists "$vault_name" ||
    _die 1 "Unknown vault: '$vault_name', available names are: $(vault_list_names | tr '\n' ',')"
  [[ ! -d "$vault_dir" ]] || _die 0 "Already opened in $vault_dir"

  # Fetch default recipients
  if [[ -z "$ident" ]]; then
    ident=$(vault_ident_names "$vault_name")
    local count=$(wc -l <<<"$ident")
    if [[ "$count" -eq 0 ]]; then
      _die 1 "Failed to fetch vault associated ids: $vault_name"
    elif [[ "$count" -gt 1 ]]; then
      # TODO: Allow ot manage current ID
      ident_names=$(xargs <<<"$ident")
      _die 1 "Too many ids for vault '$vault_name', choose one of: ${ident_names// /,}"
    fi
  fi

  # Load ident
  load_ident "$ident"

  _log DEBUG "Opening vault with ident '$ident' in: $vault_dir"

  ensure_dir "$vault_dir"
  if ! $APP_DRY; then
    _age_decrypt_with_ident \
      --output - "$vault_enc" | tar -xz -C "$vault_dir"
    local rc=$?
    if [[ "$rc" -ne 0 ]]; then
      _exec rmdir "$vault_dir"
      _die 1 "Failed to decrypt file: $vault_enc"
    fi
  fi
  _log INFO "Vault '$vault_name' opened successfully in $vault_dir"

}

# Init loaders
# =================

# VALIDATED
# Init app
data_init() {

  # export PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
  export PROJECT_ROOT=$PWD
  [[ -d "$PROJECT_ROOT" ]] ||
    _die 1 "Can't find project root. Are you in a git repo ?"

  # Go to the root project
  cd "$PROJECT_ROOT"
  export APP_DATA_DIR="${PROJECT_ROOT}"

  export APP_IDENT_DIR="${APP_DATA_DIR}/identities"
  export APP_STORES_DIR="${APP_DATA_DIR}/stores"
  export APP_VAULTS_DIR="${APP_DATA_DIR}/vaults"

  # Prepare config
  APP_CONFIG_FILE="${APP_DATA_DIR}/cryptobox.ini"
  APP_CONFIG_FILE_HASH=$(hash_sum "__config__")
  APP_CONFIG_FILE_ENC="${APP_STORES_DIR}/${APP_CONFIG_FILE_HASH}.age"
}

# VALIDATED
load_ident() {
  local ident_name=$1

  [[ -z "${APP_IDENT_NAME:-}" ]] || return 0

  export APP_IDENT_NAME=$ident_name
  export APP_IDENT_HASH=$(hash_sum "$ident_name")

  # Export identity file
  export APP_IDENT_FILE_ENC="${APP_IDENT_DIR}/${APP_IDENT_HASH}.age"
  export APP_IDENT_FILE_CLEAR="${APP_IDENT_DIR}/${APP_IDENT_HASH}.id"
  export APP_IDENT_PRIV_KEY=
  export APP_IDENT_PUB_KEY=

  # Export best ident file
  export APP_IDENT_FILE="${APP_IDENT_FILE_ENC}"
  export APP_IDENT_FILE_STATUS="encrypted"
  if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
    APP_IDENT_FILE="${APP_IDENT_FILE_CLEAR}"
    APP_IDENT_FILE_STATUS="clear"
  fi

  # User personal vault
  export APP_IDENT_VAULT_NAME="ident_$ident_name"
  export APP_IDENT_VAULT_HASH=$(hash_sum "$APP_IDENT_VAULT_NAME")
  export APP_IDENT_VAULT_FILE_ENC="${APP_STORES_DIR}/${APP_IDENT_VAULT_HASH}.age"

  # User best passowrd
  # export APP_IDENT_PASSWORD=$(keyring_get_best_secret "$APP_IDENT_NAME")

}

# Inject private user key password
load_ident_password() {

  [[ -z "${APP_IDENT_PRIV_KEY:-}" ]] || return 0
  local private_key=

  # Fetch secret from keyring
  private_key=$(keyring_get_best_secret "${APP_IDENT_NAME}")

  # Read private key in memory
  if [[ -z "$private_key" ]]; then
    if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
      private_key=$(cat "$APP_IDENT_FILE_CLEAR")
    elif [[ -f "$APP_IDENT_FILE_ENC" ]]; then
      private_key=$(
        age --decrypt \
          -o - "$APP_IDENT_FILE_ENC"
      )
    # else
    #   _log WARN "Could not find keypair for ident: $APP_IDENT_NAME"
    fi
  fi

  private_key=$(grep '^AGE-SECRET-KEY-' <<<"$private_key")
  [[ -n "$private_key" ]] ||
    _die 1 "Could not read user private key ..."

  APP_IDENT_PRIV_KEY=$private_key
  APP_IDENT_PUB_KEY=$(echo "$private_key" | age-keygen -y)

}

# CLI General Commands
# =================

cli__conf() {
  : "[ls|add|set|rm|get],Update donfiguration"

  _dir_db "$@"

}

dir_lib_encrypt_meta() {

  [[ -f "$APP_CONFIG_FILE" ]] || _die 0 "Already encrypted"

  local dest_hash=$(hash_sum "__config__")
  local vaulted_file=${APP_STORES_DIR}/$dest_hash.age

  all_pub=$(lib_id_get_all_pub_keys)
  age_recipient_args=$(_age_build_recipients_args "$all_pub")

  [[ -n "$age_recipient_args" ]] || _die 1 "Could not build all recipients list"
  local ret=

  # shellcheck disable=SC2086
  _exec age --encrypt \
    $age_recipient_args \
    --armor \
    --output "$vaulted_file" "$APP_CONFIG_FILE"
  ret=$?
  [[ "$ret" -eq 0 ]] || _die "$ret" "Something went wrong while encrypting config"

  _exec rm "$APP_CONFIG_FILE"
  _log INFO "Config vaulted in: $vaulted_file"

}

dir_lib_decrypt_meta() {
  local dest_hash=

  dest_hash=$(hash_sum "__config__")
  local vaulted_file=${APP_STORES_DIR}/${dest_hash}.age

  _age_decrypt_with_ident \
    --output "$APP_CONFIG_FILE" "$vaulted_file"

}

cli__lock() {
  : ",Lock all vaults"

  _log DEBUG "Lock all vaults and config"

  # Check all opened vaults
  for vault in $(lib_vault_opened_names); do
    _log DEBUG "Close vault: $vault"
    cli__vault__close "$vault"
  done

  # Close config
  dir_lib_encrypt_meta
}

cli__unlock() {
  : "ID,Unlock config"

  if [[ -z "${1:-}" ]]; then
    _die 1 "You must use an ident to unlock the vault"
  fi

  load_ident "$1"

  _log DEBUG "Unlock global config with ident: $APP_IDENT_NAME"

  # Decrypt metadata
  dir_lib_decrypt_meta "$APP_IDENT_FILE"

  local mode='all'

  case "$mode" in
  all)
    for vault in $(vault_list_names_for_id "$APP_IDENT_NAME"); do
      # _log INFO "Opening vault: $vault"
      cli__vault__open "$vault" "$APP_IDENT_NAME"
    done
    ;;
  user)
    if vault_assert_exists "$APP_IDENT_VAULT_NAME" ; then
      _log INFO "Unlocking user vault for: $APP_IDENT_NAME"
      cli__vault__open "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
    fi
    ;;
  esac
}

cli__sync() {
  : ",Pull, add, commit and push"

  # Check all opened vaults
  for vault in $(lib_vault_opened_names); do
    _log DEBUG "Update vault: $vault"
    lib_vault_push "$vault"
  done

  # Update config
  git pull

  # Prepare push
  git add stores identities
  git commit -m 'update vault' .
  git push

}

# CLI encrypt/decrypt Commands
# =================

cli__decrypt() {
  : "FILE,Decrypt a file"
  local file=$1
  # load_ident
  _age_decrypt_file "$file" "$2"
}

cli__encrypt() {
  : "FILE,Encrypt a file"
  local file=$1
  load_ident
  _age_encrypt_file "$file" "$APP_USER_IDENTITY_FILE"
}

# CLI Ident Commands
# =================

# Display help message
cli__id_usage() {
  cat <<EOF
${APP_NAME}: Manage ids (Subcommand example)

usage: ${APP_NAME} id [OPTS] add NAME
       ${APP_NAME} id [OPTS] rm NAME
       ${APP_NAME} id [OPTS] ls NAME
       ${APP_NAME} id help
EOF
}

# Read CLI options, shows id level options
cli__id_options() {
  while [[ -n "${1:-}" ]]; do
    # : "parse-opt-start"
    case "$1" in
    -h | --help | help)
      : ",Show help"
      clish_help cli__id
      _die 0
      ;;
    -a | --all)
      : ",Select all"
      mode=all
      shift
      ;;
    -m | --message)
      : "MSG,Define message"
      [[ -n "${2:-}" ]] || _die 1 "Missing message"
      msg=$2
      shift 2
      ;;
    -*)
      _die 1 "Unknown option: $1"
      ;;
    *)
      args=("$@")
      shift $#
      ;;
    esac
    # : "parse-opt-stop"
  done
}

cli__id() {
  : "COMMAND,Manage ids"

  # Set default vars
  local msg="Default message"
  local mode="limited"
  local args=

  # Parse args
  clish_parse_opts cli__id "$@"
  set -- "${args[@]}"

  _db_ensure_open

  # Dispatch to sub commands
  clish_dispatch cli__id__ "$@" || _die $?
}

# Basic simple level sub-commands
# ---------------
cli__id__new() {
  : "NAME,Add new identity"
  local ident_=${1:-}
  local ident=''
  local email=''

  # Validate ident
  while [[ -z "$ident" ]]; do
    _input2 "${ident:-$ident_}" "Name of the new ident"
    ident=$REPLY
    if lib_id_exists "$ident"; then
      _log WARN "This id already exists, please choose another one."
      ident=
    fi
  done

  # Ask for email
  _input2 "$ident@$(hostname -f)" "Email"
  email=$REPLY

  # Create new ident
  lib_id_new_ident__age "$ident"

  # Set ident informations
  _dir_db set "ident.$ident.login" "$ident_"
  _dir_db set "ident.$ident.email" "$email"

  # Create user vault
  lib_vault_new "ident_${ident}" "$ident"

}

cli__id__ls() {
  : "NAME,List idents"

  lib_id_list

}

cli__id__keypair() {
  : "NAME,Show identity key pair (require unlock password)"
  load_ident "$1"
  load_ident_password

  echo "ident: $APP_IDENT_NAME"
  echo "ident: $APP_IDENT_HASH"
  echo "public: $APP_IDENT_PUB_KEY"
  echo "private: $APP_IDENT_PRIV_KEY"
}

cli__id__rm() {
  : "NAME,Remove identiry"
  lib_id_rm_ident__age "$1"
}

cli__id__keyring() {
  : "IDENT,Set ident in local keyring"
  local ident=$1
  load_ident "$1"
  load_ident_password

  # Store in keyring
  printf "%s" "$APP_IDENT_PRIV_KEY" |
    secret-tool store \
      --label="SecretMgr Ident - $ident" \
      application "$APP_NAME" \
      "${APP_NAME}-ident" "$ident"

  _log INFO "Identity has been added to keyring"
}

# CLI Vault Commands
# =================

# Display help message
cli__vault_usage() {
  cat <<EOF
${APP_NAME}: Manage vaults (Subcommand example)

usage: ${APP_NAME} vault [OPTS] add NAME
       ${APP_NAME} vault [OPTS] rm NAME
       ${APP_NAME} vault help
EOF
}

# Read CLI options, shows vault level options
cli__vault_options() {
  while [[ -n "${1:-}" ]]; do
    # : "parse-opt-start"
    case "$1" in
    -h | --help | help)
      : ",Show help"
      clish_help cli__vault
      _die 0
      ;;
    -a | --all)
      : ",Select all"
      mode=all
      shift
      ;;
    -m | --message)
      : "MSG,Define message"
      [[ -n "${2:-}" ]] || _die 1 "Missing message"
      msg=$2
      shift 2
      ;;
    -*)
      _die 1 "Unknown option: $1"
      ;;
    *)
      args=("$@")
      shift $#
      ;;
    esac
    # : "parse-opt-stop"
  done
}

cli__vault() {
  : "COMMAND,Manage vaults"

  # Set default vars
  local msg="Default message"
  local mode="limited"
  local args=

  # Parse args
  clish_parse_opts cli__vault "$@"
  set -- "${args[@]}"

  _db_ensure_open

  # Dispatch to sub commands
  clish_dispatch cli__vault__ "$@" || _die $?
}

# Basic simple level sub-commands
# ---------------

cli__vault__new() {
  : "NAME [ID...],Create new vault"
  lib_vault_new "$@"
}

cli__vault__ls() {
  : ",List vaults"

  if [[ "$#" -eq 0 ]]; then
    vault_list_names
  else
    vault_list_names_for_id "$1"
  fi
}

cli__vault__rm() {
  : "NAME,Remove subcommand"
  lib_vault_rm "$@"
}

cli__vault__close() {
  : "NAME,Close vault"
  lib_vault_lock "$@"
}

cli__vault__open() {
  : "NAME [ID...],Open or create vault"
  lib_vault_unlock "$@"
}

# # Nested command names
# # ---------------
# cli__secret__var ()
# {
#   : "," # Ignored from help
#   clish_dispatch cli__secret__var__ "$@" \
#     || _die $? "secret command failed with error: $?"
# }

# cli__secret__var__get()
# {
#   : "VAR,Get variable"
#   echo "Value of var $1 is current date: $(date)"
# }

# cli__secret__var__set()
# {
#   : "VAR VALUE,Set variable value"
#   local name=$1
#   shift
#   [ $# -gt 0 ] || return 42
#   echo "Value of var '$name' set to: $@"
# }

# # CLI Sub Commands
# # =================

# # Display help message
# cli__group_usage ()
# {
#   cat <<EOF
# ${APP_NAME}: Manage groups (Subcommand example)

# usage: ${APP_NAME} group [OPTS] add NAME
#        ${APP_NAME} group [OPTS] rm NAME
#        ${APP_NAME} group help
# EOF
# }

# # Read CLI options, shows group level options
# cli__group_options ()
# {
#   while [[ -n "${1:-}" ]]; do
#     # : "parse-opt-start"
#     case "$1" in
#       -h|--help|help)
#         : ",Show help"
#         clish_help cli__group; _die 0
#         ;;
#       -a|--all)
#         : ",Select all"
#         mode=all
#         shift
#         ;;
#       -m|--message)
#         : "MSG,Define message"
#         [[ -n "${2:-}" ]] || _die 1 "Missing message"
#         msg=$2
#         shift 2
#         ;;
#       -*)
#         _die 1 "Unknown option: $1"
#         ;;
#       *)
#         args=("$@")
#         shift $#
#       ;;
#     esac
#     # : "parse-opt-stop"
#   done
# }

# cli__group ()
# {
#   : "COMMAND,Manage groups"

#   # Set default vars
#   local msg="Default message"
#   local mode="limited"
#   local args=

#   # Parse args
#   clish_parse_opts cli__group "$@"
#   set -- "${args[@]}"

#   # report to user
#   _log INFO "Requested mod: $mode"
#   _log INFO "Requested message: $msg"

#   # Dispatch to sub commands
#   clish_dispatch cli__group__ "$@" || _die $?
# }

# # Basic simple level sub-commands
# # ---------------
# cli__group__add()
# {
#   : "NAME [OPTS],Add subcommand"
#   echo "Add: '$1' in '$mode' mode with message: '$msg'"
# }

# cli__group__rm()
# {
#   : "NAME,Remove subcommand"
#   echo "Remove: $1"
# }

# # Nested command names
# # ---------------
# cli__group__var ()
# {
#   : "," # Ignored from help
#   clish_dispatch cli__group__var__ "$@" \
#     || _die $? "Group command failed with error: $?"
# }

# cli__group__var__get()
# {
#   : "VAR,Get variable"
#   echo "Value of var $1 is current date: $(date)"
# }

# cli__group__var__set()
# {
#   : "VAR VALUE,Set variable value"
#   local name=$1
#   shift
#   [ $# -gt 0 ] || return 42
#   echo "Value of var '$name' set to: $@"
# }

# Core App
# =================

# App initialization
cli_init() {
  # Useful shortcuts
  export VCS_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
  export SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
  export WORK_DIR=${VCS_DIR:-${SCRIPT_DIR:-$PWD}}
  export PWD_DIR=${PWD}
}

# Check if all required bin are available in PATH
cli_require() {
  local deps=${@:-${APP_DEPENDENCIES:-}}

  local prog=
  for prog in ${deps-}; do
    _check_bin "$prog" || {
      _die 2 "Can't find '$prog', please install it first"
    }
  done
}

# App help message
cli_usage() {
  cat <<EOF
${APP_NAME} is command line tool to manage secrets in git repos.

usage: ${APP_NAME} <COMMAND> <TARGET> [<ARGS>]
       ${APP_NAME} help
EOF
}

# Parse CLI options
cli_options() {
  while [[ -n "${1:-}" ]]; do
    # : "parse-opt-start"
    case "$1" in
    -h | --help)
      : ",Show this help message"
      args=("help" "$@")
      shift
      ;;
    -n | --dry)
      : ",Enable dry mode"
      _log INFO "Dry mode enabled"
      APP_DRY=true
      shift
      ;;
    -f | --force)
      : ",Enable force mode"
      _log INFO "Force mode enabled"
      APP_FORCE=true
      shift
      ;;
    -V | --version)
      : ",Show version"
      echo "$APP_VERSION"
      _die 0
      ;;
    -v | -vv | -vvv | --verbose)
      : "[LEVEL],Set verbosity level"
      if [[ "$1" == "-vv" ]]; then
        APP_LOG_LEVEL=DEBUG
      elif [[ "$1" == "-vvv" ]]; then
        APP_LOG_LEVEL=TRACE
      else
        [[ -n "${2:-}" ]] || _die 1 "Missing log level value"
        APP_LOG_LEVEL=$2
        shift 1
      fi
      shift 1
      _log INFO "Log level set to: $APP_LOG_LEVEL"
      ;;
    -*)
      _die 1 "Unknown option: $1"
      ;;
    *)
      args=("$@")
      shift $#

      # To enable greedy parsing
      # args+=( "$1" )
      # shift 1
      ;;
    esac
    # : "parse-opt-stop"
  done
}

cli() {
  # Init
  trap '_sh_trap_error $? ${LINENO} trap_exit 42' EXIT

  # Parse CLI flags
  clish_parse_opts cli "$@"
  set -- "${args[@]}"

  # Init app
  cli_init

  data_init

  # Route commands before requirements
  local cmd=${1:-help}
  shift 1 || true
  case "$cmd" in
  -h | --help | help | h)
    clish_help cli
    _die 0
    ;;
  esac

  # Check requirements
  cli_require

  # Dispatch subcommand
  clish_dispatch cli__ "$cmd" "$@" ||
    _die $? "Command '$cmd' returned error: $?"
}

cli "${@}"
