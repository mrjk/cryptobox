#!/bin/bash
# TEMPLATE_VERSION=2024-08-18

# Basic bash template for command/resource based CLI.
# Features:
# * Automatic command discovery and help generation
# * Logging and traces
# * Application dependency checker
# * Support for getopts
# * Return code support
# * Command executor with dry mode


# shellcheck disable=SC2155


set -euo pipefail

# App Global variable
# =================

# Global vars
APP_SCRIPT="${0##*/}"
APP_NAME="${APP_SCRIPT%.*}"

# Metadata vars
APP_AUTHOR="author"
APP_EMAIL="email@address.org"
APP_LICENSE="GPLv3"
APP_URL="https://github.com/$APP_AUTHOR/$APP_NAME"
APP_REPO="https://github.com/$APP_AUTHOR/$APP_NAME.git"
APP_GIT="git@github.com:$APP_AUTHOR/$APP_NAME.git"

APP_STATUS=alpha
APP_DATE="2024-08-01"
APP_VERSION=0.0.1

# App configuration
APP_LOG_SCALE="TRACE:TRACE3:TRACE2:TRACE1:DEBUG:DEBUG3:DEBUG2:DEBUG1:RUN:INFO:DRY:NOTICE:HINT:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT"
#APP_DEPENDENCIES="column tree"
# set -x

APP_DRY=${APP_DRY:-false}
APP_FORCE=${APP_FORCE:-false}
APP_LOG_LEVEL=INFO # DRY, DEBUG, TRACE

# Automatic vars
# set -x
APP_IS_INTERACTIVE=${APP_IS_INTERACTIVE:-$([ -t 0 ] && echo true || echo false)}
SCRIPT_REAL_PATH=$(realpath  "$0")
SCRIPT_REAL_DIR=$(cd -- "$(dirname -- "$SCRIPT_REAL_PATH")" &>/dev/null && pwd)
APP_REAL_NAME=$(basename "$SCRIPT_REAL_PATH")
# set +x

APP_CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/$APP_REAL_NAME

SCRIPT_LIB="${SCRIPT_REAL_DIR}/../lib"

APP_CONFIG_KEY_PROJECT=cryptobox.project
APP_SUBPATH_CONTEXT=true
APP_ENABLE_KEYRING=true

# Load internal libs
# source "$SCRIPT_LIB/utils.sh"
# source "$SCRIPT_LIB/idents.sh"
# source "$SCRIPT_LIB/backends.sh"


source "$SCRIPT_LIB/lib_utils.sh"
source "$SCRIPT_LIB/lib_clish.sh"
source "$SCRIPT_LIB/lib_conf.sh"
source "$SCRIPT_LIB/lib_resources.sh"

source "$SCRIPT_LIB/cli_idents.sh"
# source "$SCRIPT_LIB/cli_gitvault.sh"
source "$SCRIPT_LIB/cli_vault.sh"


# Init loaders
# =================

# Init loaders
# =================

find_top_project_path() {
    local current_dir="$1"

    _log TRACE "Scan path: $current_dir"

    # Check if we're at the root directory
    if [ "$current_dir" = "/" ]; then
        _log TRACE "Reached root directory without finding the top project path." >&2
        return 1
    fi

    # Check if we're in a git repository
    if ! git -C "$current_dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        _log TRACE "Not inside a git repository." >&2
        return 1
    fi

    # Get the root of the current git repository
    local git_root
    git_root=$(git -C "$current_dir" rev-parse --show-toplevel)

    # Check if we're at the root of the git repository
    if [ "$current_dir" != "$git_root" ]; then
        _log TRACE "Go to git root directory: $git_root" >&2
        find_top_project_path "$git_root"
        return $?
    fi

    # Query git config for IS_ROOT
    local is_root
    is_root=$(git -C "$current_dir" config --get "$APP_CONFIG_KEY_PROJECT" || echo "false")

    if [ "$is_root" = "true" ]; then
        _log DEBUG "Found root project: $current_dir" >&2
        echo "$current_dir"
        return 0
    elif [ -z "$is_root" ] || [ "$is_root" = "false" ]; then
        local target="$(dirname "$current_dir")"
        _log TRACE "Not root project, try parent: $target" >&2

        find_top_project_path "$target"
        return $?
    else
        _log TRACE "Error: Invalid value for $APP_CONFIG_KEY_PROJECT: $is_root" >&2
        return 1
    fi
}

# Init loaders
# =================


# Init app
cb_init_app() {
  local target_dir=${1:-$PWD}

  # Determine cryptobox project path
  export PROJECT_ROOT=$target_dir
  PROJECT_ROOT=$(find_top_project_path "$PROJECT_ROOT") \
     || {
        _log HINT "Cryptobox project can't be found in parent directory."
        _log HINT "Are you in a cryptobox repo?"
        _log HINT "To create a new cryptobox repo here, run: $APP_NAME init ."
        _die 1 "Could not find cryptobox project"
     }
  _log DEBUG "App project dir: $PROJECT_ROOT ($$)"

  # Calculate subpath relative to root dir
  export APP_SUBPATH=''
  [[ "$PWD" != "$PROJECT_ROOT"* ]] \
    || APP_SUBPATH=${PWD#$PROJECT_ROOT}

  # Go to the root project
  cd "$PROJECT_ROOT"
  export APP_SEED="0000"
  export APP_INSTANCE="$(hostname -f)-$(hash_sum "$PROJECT_ROOT" | head -c 8)"
  export APP_DATA_DIR="${PROJECT_ROOT}"

  export APP_IDENT_DIR="${APP_DATA_DIR}/identities"
  export APP_STORES_DIR="${APP_DATA_DIR}/stores"
  export APP_VAULTS_DIR="${APP_DATA_DIR}/vaults"
  export APP_SPOOL_DIR="${APP_DATA_DIR}/.spool"

  # Prepare config
  APP_CACHE_FILE="$APP_SPOOL_DIR/secret_hash.ini"
  # APP_CONFIG_FILE="${APP_DATA_DIR}/cryptobox.ini"
  APP_CONFIG_FILE="${APP_VAULTS_DIR}/CRYPTOBOX/cryptobox.ini"
  APP_CONFIG_FILE_HASH=$(hash_sum "__config__")
  APP_CONFIG_FILE_ENC="${APP_STORES_DIR}/${APP_CONFIG_FILE_HASH}.age"

  # Prepare context var
  export APP_DEFAULT_IDENT_NAME=''
  export APP_DEFAULT_VAULTS_NAME=''

}

cb_init_ctx () {
  local ident=''
  local vault_name=''

  # Check ident from environment vars
  if [[ -n "${CRYPTOBOX_IDENT:-}" ]]; then
    ident=$CRYPTOBOX_IDENT
  fi

  # Check ident from preference order
  if [[ -n "${APP_IDENTS_PREFERENCE}" ]]; then
    ident=${APP_IDENTS_PREFERENCE%%,*}
  fi

  # Check from dir context
  if $APP_SUBPATH_CONTEXT; then
    if [[ "$APP_SUBPATH" == "/vaults/"* ]]; then
      local vault_name="${APP_SUBPATH#/vaults/}"
      if [[ -n "$vault_name" ]]; then
        vault_name="${vault_name}"
      fi
    fi
  fi

  # Export results
  export APP_DEFAULT_IDENT_NAME=$ident
  export APP_DEFAULT_VAULTS_NAME=$vault_name
}

# VALIDATED
cb_init_ident() {
  local ident_name=$1

  # Avoid multi loading
  [[ "${APP_IDENT_LOADED:-}" != "$ident_name" ]] || return 0
  export APP_IDENT_LOADED="$ident_name"

  # Load ident
  export APP_IDENT_NAME=$ident_name
  export APP_IDENT_HASH=$(hash_sum "$ident_name")

  # Export identity file
  export APP_IDENT_FILE_ENC="${APP_IDENT_DIR}/${APP_IDENT_HASH}.age"
  export APP_IDENT_FILE_CLEAR="${APP_IDENT_DIR}/${APP_IDENT_HASH}.id"
  export APP_IDENT_PRIV_KEY=
  export APP_IDENT_PUB_KEY=

  # Export best ident file
  export APP_IDENT_FILE="${APP_IDENT_FILE_ENC}"
  export APP_IDENT_FILE_STATUS="encrypted"
  if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
    APP_IDENT_FILE="${APP_IDENT_FILE_CLEAR}"
    APP_IDENT_FILE_STATUS="clear"
  fi

  # User personal vault
  export APP_IDENT_VAULT_NAME="ident_$ident_name"
  export APP_IDENT_VAULT_HASH=$(hash_sum "$APP_IDENT_VAULT_NAME")
  export APP_IDENT_VAULT_FILE_ENC="${APP_STORES_DIR}/${APP_IDENT_VAULT_HASH}.age"

  # User best passowrd
  # export APP_IDENT_PASSWORD=$(keyring_get_best_secret "$APP_IDENT_NAME")

}

# Inject private user key password
cb_init_ident_pass() {

  [[ -z "${APP_IDENT_PRIV_KEY:-}" ]] || return 0
  local private_key=''

  [[ -n "$APP_IDENT_NAME" ]] || {
    _die 1 "Missing ident"
  }
    
  # Fetch secret from keyring
  if $APP_ENABLE_KEYRING; then
    private_key=$(keyring_get_best_secret "${APP_IDENT_NAME}")
    if [[ -n "$private_key" ]]; then
      _log INFO "Using '$APP_IDENT_NAME' passphrase from local keyring"
    else
      # _log HINT "You can save $APP_IDENT_NAME password in local keyring with command: cryptobox id keyring $APP_IDENT_NAME"
      _log DEBUG1 "No entries in local keyring for: $APP_IDENT_NAME"
    fi
  fi

  # Read private key in memory
  if [[ -z "$private_key" ]]; then
    if [[ -f "$APP_IDENT_FILE_CLEAR" ]]; then
      private_key=$(cat "$APP_IDENT_FILE_CLEAR")
    elif [[ -f "$APP_IDENT_FILE_ENC" ]]; then
      _log USER "Please enter main password for '$APP_IDENT_NAME' identity"
      private_key=$(
        age --decrypt \
          -o - "$APP_IDENT_FILE_ENC"
      ) || {
        _log HINT "You probably made a mistake on your passphrase"
        _die 1 "Could not read main password for '$APP_IDENT_NAME' identity or try with --no-keyring"

      }
      
    else
      _log WARN "Could not find keypair for ident: $APP_IDENT_NAME"
    fi
  fi

  # VAlidate private key
  [[ -n "$private_key" ]] ||
    _die 1 "Empty ident private key"
  private_key=$(grep '^AGE-SECRET-KEY-' <<<"$private_key")
  [[ -n "$private_key" ]] ||
    _die 1 "Private key is not an AGE-SECRET-KEY format"


  # Ask user to save password in keyring ?
  # if ! $APP_ENABLE_KEYRING; then
  #   _log HINT "You can save $APP_IDENT_NAME password in local keyring:cryptobox id keyring $APP_IDENT_NAME"
  # fi

  APP_IDENT_PRIV_KEY=$private_key
  APP_IDENT_PUB_KEY=$(echo "$private_key" | age-keygen -y)

}


# Metadata config
# =================

# Init a new cryptobox repo
cb_init () {
  cd "$APP_PWD_DIR"

  local target="${1:-.}"

  # Ensure target dir exsists
  [[ -d "$target" ]] \
    || _exec mkdir -p "$target" >/dev/null \
    || _die $? "Failed to created directory: $target"

  # Ensure targfet dir is git repo
  # is_dir_git_repo "$target" \
  [[ -d "$target/.git" ]] \
    || {
      _log INFO "Create new empty git repository in: $target"
      _exec git init "$target" >/dev/null || \
        _die 1 "Failed to create git repo in: $target"

      # Prepare gitignore
      echo "vaults/**" >> "$target/.gitignore"
      echo ".spool/**" >> "$target/.gitignore"
      echo "*.swp" >> "$target/.gitignore"
      git -C "$target" add ".gitignore" >/dev/null
      git -C "$target" commit -m 'Init repo' ".gitignore" >/dev/null
    }

  # Ensure git is correctly setup
  local current_val=$(git -C "$target" config get  --local "$APP_CONFIG_KEY_PROJECT")
  if [[ "$current_val" == "true" ]] ; then
      _log INFO "Already configured with cryptobox: $target"
  else
    _exec git -C "$target" config set  --local   "$APP_CONFIG_KEY_PROJECT" true
    _log INFO "New cryptobox repository created in: $target"
  fi

  # Change root project dir:
  cb_init_app "$target"

  # Ensure DB is ready
  item_new_config "CRYPTOBOX" "ALL" || \
    _die $? "Failed to create db in!"

}


# cb_config_encrypt() {
#   local dest_hash=$APP_CONFIG_FILE_HASH
#   local _vaulted_file="${APP_STORES_DIR}/${dest_hash}.age"
#   local vaulted_file=${1:-$_vaulted_file}


#   [[ -f "$APP_CONFIG_FILE" ]] || _die 0 "Already encrypted"

#   # local vaulted_file=${APP_STORES_DIR}/$dest_hash.age

#   all_pub=$(lib_id_get_all_pub_keys)
#   age_recipient_args=$(_age_build_recipients_args "$all_pub")

#   [[ -n "$age_recipient_args" ]] || _die 1 "Could not build all recipients list"
#   local ret=

#   # Decrypt the current file, and get checksum
#   export ret=0
#   local commited_content_hash=''
#   commited_content_hash=$(
#     _age_decrypt_with_ident \
#     --output - "$vaulted_file" \
#     | hash_sum - 
#     ) || _die 1 "Failed to get content hash, please identify yourself"
#   _log CRIT "YOOOOOOOOOOOO: $ret"

#   # Decrypt local config and get hash
#   local curr_hash=$(cat "$APP_CONFIG_FILE" | hash_sum - )

#   # Quit if nothing to do
#   if [[ "$commited_content_hash" == "$curr_hash" ]] ; then
#     _log INFO "No need to reencrypt config"
#     # set -x
#     return 0
#   fi

#   # shellcheck disable=SC2086
#   _exec age --encrypt \
#     $age_recipient_args \
#     --armor \
#     --output "$vaulted_file" "$APP_CONFIG_FILE" || \
#       _die "Failed to encrypt file: $APP_CONFIG_FILE"


#   _log INFO "Config updated in vault: $vaulted_file"

# }

# cb_config_decrypt() {
#   local dest_hash=$APP_CONFIG_FILE_HASH
#   local _vaulted_file="${APP_STORES_DIR}/${dest_hash}.age"
#   local vaulted_file=${1:-$_vaulted_file}

#   local dest=$APP_CONFIG_FILE
#   local tmp_dst="${dest}.new"

#   [[ ! -e "$tmp_dst" ]] || _exec rm "$tmp_dst"
#   _age_decrypt_with_ident \
#     --output "$tmp_dst" "$vaulted_file" || \
#     _die "Failed to decrypt file: $vaulted_file"

#   # Do the change ?
#   local new_hash=$(cat "$tmp_dst" | hash_sum - )
#   local curr_hash=$(cat "$dest" | hash_sum - )

#   if [[ "$new_hash" == "$curr_hash" ]] ; then
#       rm "$tmp_dst"
#     _log INFO "Config did not changed"
#     return 0
#   fi


#   if [[ -f "$dest" ]]; then

#     local changes=$(diff -U 0 "$dest" "$tmp_dst" | tail -n+4)
#     local checksum_excluded=$(grep -v 'checksum = ' <<<"$changes" )

#   #   echo "RESULT1: |$changes|"
#   #   echo "RESULT2: |$checksum_excluded|"
#   # set +x
#     local erase=true

#     if [[ -z "$checksum_excluded" ]]; then
#       _log INFO "Update only item hash in config, safe to overwrite config"
#       erase=true
#     else
#       _log WARN "Configuration changed for: $dest"
#       colordiff -u "$tmp_dst" "$dest"
#       _log WARN "Configuration will be updated:"

#       erase=false
#       if ! $APP_FORCE; then
#         _confirm \
#           "Do you want to add these changes to config?" || \
#           erase=true
#       fi
#     fi

#     if $erase; then
#       _exec mv "$tmp_dst" "$dest" 
#       _log INFO "Update $dest config from upstream"
#     else
#       _log INFO "Keep $dest config from local"
#       _exec rm "$tmp_dst"
#     fi
#   else
#     _log INFO "Create new $dest config"
#     _exec mv "$tmp_dst" "$dest" 
#   fi
  
# }


# cb_sync (){
#   local ident=$1
#   cb_pull "$ident"

#   if _is_git_diverged "main"; then
#     cb_fix "$ident"
#   fi

#   cb_push "$ident"

#   _log INFO "Repo is now fully synced"

# }

cb_pull() {
  : ",Pull add commit and push"
  local ident=$1

  local cli_vaults=$(ident_vault_list "$1")

  for vault in ${cli_vaults//,/ }; do
    _log INFO "Pull vault: $vault"
    if item_pull "$vault" "$cli_ident"; then
      _log NOTICE "Pulled vault '$vault'"
    else
      _log WARN "Failed to pull vault '$vault'"
    fi
  done
  return

  # # cb_init_ident "$ident"

  # _log INFO "Start pull"

  # # Update config
  # _exec git pull --ff -Xtheirs
  # cb_config_decrypt
  # items_pull_opened "$ident"

  # if _is_git_diverged "main"; then
  # _log WARN "Remote branch changed from local branch, please run: '$APP_NAME fix $ident'"
  # _log INFO "Partial pull with fork, please fix"

  # else
  # _log INFO "Pulled with success"
  # fi

}


cb_push() {
  : ",Add commit and push"
  local ident=$1


  local cli_vaults=$(ident_vault_list "$1")

  for vault in ${cli_vaults//,/ }; do
    _log INFO "Push vault: $vault"
    if item_push "$vault" "$cli_ident"; then
      _log NOTICE "Pushed vault '$vault'"
    else
      _log WARN "Failed to push vault '$vault'"
    fi
  done
  return


  # # Prepare ident
  # cb_init_ident "$ident"
  # for vault_name in $(ident_vault_list "$ident"); do
  #   _log NOTICE "Push vault: $vault_name"
  #   item_push "$vault_name" "$ident"
  # done
  #   _log NOTICE "All encrypted vaults has been updated"

  # # Push local code
  # if ! is_in_git_clean_stage "stores" \
  #   || ! is_in_git_clean_stage "identities" \
  #   ; then

  #   _log INFO "New changes to commit"
  #   _exec git add stores identities
  #   _exec git commit --untracked-files=no -m 'update vault' stores identities

  #   if [[ -n "$(git remote -v )" ]]; then
  #     _exec git push
  #     _log NOTICE "Changes pushed remotely"
  #   else
  #     _log NOTICE "Cryptobox repo updated (no remotes)"
  #   fi
  # else
  #   _log NOTICE "Ok, no changes detected"
  # fi
}


# cb_fix() {
#   : ",Fix diverging remote branches"

#   local ident=$1
#   local local_br="main"
#   local upstream_br="origin/main"
#   local upstream_prefix=.merge

#   if ! _is_git_diverged "$local_br"; then
#     _log INFO "Nothing to fix, try '$APP_NAME pull $ident'"
#     _die 0 "No need to fix cryptobox"
#   fi

#   cb_init_ident "$ident"


#   _log INFO "Compare changes from upstream"
#   local has_changes=false
#   local config_changed=''
#   local idents_changed=''
#   local stores_changed=''

#   for file in $(git diff --name-only  "$local_br" "$upstream_br"); do
#     # echo CAHNGED FILE: $file

#     has_changes=true

#     local change=''
#     if [[ "$file" == "stores/${APP_CONFIG_FILE_HASH}.age" ]]; then
#       change=config
#       config_changed=$file
#     elif [[ "$file" == "stores/"* ]]; then
#       change=store
#       stores_changed="${stores_changed}:${file}"
#     elif [[ "$file" == "identities/"* ]]; then
#       change=ident
#       idents_changed="${idents_changed}:${file}"
#     fi
#     echo "  Type of change: $change => $file"

#   done


#   _log INFO "Apply changes from upstream"
#   local _old_store_dir=$APP_STORES_DIR
#   export APP_STORES_DIR="$upstream_prefix/stores"


#   git worktree add "$upstream_prefix" "$upstream_br"


#   if [[ -n "$config_changed" ]]; then
#     _log INFO "Updating from upstream config ..."

#     local target_enc="${APP_CONFIG_FILE}.new.enc"
#     git show  origin/main:$config_changed > "$target_enc"

#     cb_config_decrypt "$target_enc"
#     rm "$target_enc"
#   fi

#   if [[ -n "$idents_changed" ]]; then
#     _log INFO "Updating from upstream idents ..."
#     _die 1 "Ident update not implemented yet"
#   fi


#   if [[ -n "$stores_changed" ]]; then
#     _log INFO "Updating from upstream stores ..."

#     for store in ${stores_changed//:/ }; do
#       needle=${store##*stores/}
#       needle=${needle%%.age}
#       store_name=$(item_name_from_hash "$needle")
#       store_kind=$(item_kind "$store_name" )

#       # echo "$store_kind"
#       _log INFO "Updating $store_kind: $store_name"
#       item_pull "$store_name" || \
#         _log WARN "Failed to pull vault: $store_name"
#       echo 
#     done
#   fi

#   _log INFO "Cleanup diverging branches"
#   # set -x
#   export APP_STORES_DIR=$_old_store_dir
#   git worktree remove -f   .merge

#   _exec git checkout "$upstream_br"
#   _exec git branch -D "$local_br"
#   _exec git checkout -b "$local_br"
#   _exec git branch --set-upstream-to=$upstream_br "$local_br"
#   # set +x


#   _log INFO "Repo is now fixed :)"

# }


# TOFIX
# =================


# cb_lock (){
#   # set -x
#   cb_init_ident "$1"


#   # Close secrets
#   local mode='all'
#   local kinds=${APP_ITEMS_KINDS}

#   for kind in $kinds; do

#     case "$mode" in
#     all)
#       for vault in $(item_ident_resources "$APP_IDENT_NAME" "$kind"); do
#         # _log INFO "Opening vault: $vault"
#         # "lib_${kind}_lock" "$vault" "$APP_IDENT_NAME"
#         item_pull "$vault" "$APP_IDENT_NAME"
#       done
#       ;;
#     user)
#       if item_assert_exists "$kind" "$APP_IDENT_VAULT_NAME" ; then
#         _log INFO "Locking user vault for: $APP_IDENT_NAME"
#         # "lib_${kind}_lock" "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
#         item_pull "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
#       fi
#       ;;
#     esac
#   done


#   # Close config
#   cb_config_encrypt

# }


# cb_unlock(){
#   cb_init_ident "$1"

#   _log DEBUG "Unlock global config with ident: $APP_IDENT_NAME"

#   # Decrypt metadata
#   cb_config_decrypt

#   # Open secrets
#   local mode='all'
#   local kinds=${APP_ITEMS_KINDS}

#   for kind in $kinds; do

#     case "$mode" in
#     all)
#       for vault in $(item_ident_resources "$APP_IDENT_NAME" "$kind"); do
#         # _log INFO "Opening vault: $vault"
#         # "lib_${kind}_unlock" "$vault" "$APP_IDENT_NAME"
#         item_pull "$vault" "$APP_IDENT_NAME"
#       done
#       ;;
#     user)
#       if item_assert_exists "$kind" "$APP_IDENT_VAULT_NAME" ; then
#         _log INFO "Unlocking user vault for: $APP_IDENT_NAME"
#         # "lib_${kind}_unlock" "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
#         item_pull "$APP_IDENT_VAULT_NAME" "$APP_IDENT_NAME"
#       fi
#       ;;
#     esac
#   done
# }



# CLI General Commands
# =================

cli__init() {
  : "[PATH],Init new cryptobox repository"
  local target="${1:-.}"

  cb_init2 "$target"
}


cli__conf() {
  : "[ls|add|set|rm|get],Update donfiguration"
  _dir_db "$@"
}

cli__lock() {
  : ",Lock all vaults"
  _log DEBUG "Lock all vaults and config"
  if [[ -z "${1:-}" ]]; then
    _die 1 "You must use an ident to unlock the vault"
  fi
  cb_lock "$@"
}

cli__unlock() {
  : "ID,Unlock config"
  [[ -n "${1:-}" ]] \
    || _die 1 "You must use an ident to unlock the vault"
  cb_unlock "$@"
}


# cli__sync() {
#   : ",Sync: pull and push"
#   [[ -n "${1:-}" ]] \
#     || _die 1 "You must use an ident to unlock the vault"
#   cb_sync "$@"
# }

cli__pull() {
  : "IDENT [VAULTS...],Pull vaults"


  local cli_ident=$APP_DEFAULT_IDENT_NAME
  local cli_vaults=''

  [[ -n "$APP_DEFAULT_IDENT_NAME" ]] \
    || _die 1 "Missing ident name"

  if [[ $# -gt 0 ]]; then
    cli_vaults=$@
  else
    cli_vaults=$APP_DEFAULT_VAULTS_NAME
  fi

  # echo cli_vaults=${cli_vaults:-}
  # echo cli_ident=${cli_ident:-}

  # Run action
  if [[ -n "$cli_vaults" ]]; then
    for vault in ${cli_vaults//,/ }; do
      if item_pull "$vault" "$cli_ident"; then
        _log NOTICE "Pulled vault '$vault'"
      else
        _log WARN "Failed to pull vault '$vault'"
      fi
    done
  elif [[ -n "$cli_ident" ]]; then
    cb_pull "$cli_ident"
    _log NOTICE "Pulled all vaults"
  else
    _die 1 "Please check syntax, missing ident or vault"
  fi
}


cli__push() {
  : ",Push vaults"

  local cli_ident=$APP_DEFAULT_IDENT_NAME
  local cli_vaults=''

  [[ -n "$APP_DEFAULT_IDENT_NAME" ]] \
    || _die 1 "Missing ident name"

  if [[ $# -gt 0 ]]; then
    cli_vaults=$@
  else
    cli_vaults=$APP_DEFAULT_VAULTS_NAME
  fi

  # Run action
  if [[ -n "$cli_vaults" ]]; then
    for vault in ${cli_vaults//,/ }; do
      if item_push "$vault" "$cli_ident"; then
        _log NOTICE "Pushed vault '$vault'"
      else
        _log WARN "Failed to push vault '$vault'"
      fi
    done
  elif [[ -n "$cli_ident" ]]; then
    cb_push "$cli_ident"
    # _log NOTICE "Pushed all vaults"
  else
    _die 1 "Please check syntax, missing ident or vault"
  fi
}

# cli__fix() {
#   : ",Fix diverging remote branches"
#   [[ -n "${1:-}" ]] \
#     || _die 1 "You must use an ident to unlock the vault"
#   cb_fix "$@"
# }

# CLI encrypt/decrypt Commands
# =================

# cli__decrypt() {
#   : "FILE,Decrypt a file"
#   local file=$1
#   # cb_init_ident
#   _age_decrypt_file "$file" "$2"
# }

# cli__encrypt() {
#   : "FILE,Encrypt a file"
#   local file=$1
#   cb_init_ident
#   _age_encrypt_file "$file" "$APP_USER_IDENTITY_FILE"
# }

cli__info() {
  : ",Show informations"
  local ident=${1:-}
  cb_init_ident "$ident" || true

  env | sort | grep APP_

}



# Core App
# =================

# App initialization
cli_init() {
  # Useful shortcuts
  export VCS_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
  export SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
  export APP_WORK_DIR=${VCS_DIR:-${SCRIPT_DIR:-$PWD}}
  export APP_PWD_DIR=${PWD}

  # Preset values
  export APP_IDENTS_PREFERENCE=''
  export APP_ENABLE_KEYRING=true
}

# Check if all required bin are available in PATH
cli_require() {
  local deps=${@:-${APP_DEPENDENCIES:-}}

  local prog=
  for prog in ${deps-}; do
    _check_bin "$prog" || {
      _die 2 "Can't find '$prog', please install it first"
    }
  done
}

# App help message
cli_usage() {
  cat <<EOF
${APP_NAME} is command line tool to manage secrets in git repos.

usage: ${APP_NAME} <COMMAND> <TARGET> [<ARGS>]
       ${APP_NAME} help
EOF
}

# Parse CLI options
cli_options() {
  while [[ -n "${1:-}" ]]; do
    # : "parse-opt-start"
    case "$1" in
    -h | --help)
      : ",Show this help message"
      args=("help" "$@")
      shift
      ;;
    -n | --dry)
      : ",Enable dry mode"
      _log INFO "Dry mode enabled"
      APP_DRY=true
      shift
      ;;
    -f | --force)
      : ",Enable force mode"
      _log INFO "Force mode enabled"
      APP_FORCE=true
      shift
      ;;
    --keyring | --no-keyring)
      : ",Enable local keyring"
      APP_ENABLE_KEYRING=false
      [[ "$1" == "--keyring" ]] && APP_ENABLE_KEYRING=true
      _log INFO "Local keyring enabled: $APP_ENABLE_KEYRING"
      shift
      ;;

    -i | --ident)
      : "IDENT,Set current ident, can have multiple values"
      _log INFO "Ident added: $2"
      APP_IDENTS_PREFERENCE=${APP_IDENTS_PREFERENCE:+$APP_IDENTS_PREFERENCE,}$2
      shift 2
      ;;
    -V | --version)
      : ",Show version"
      echo "$APP_VERSION"
      _die 0
      ;;
    -x | --xtrace)
      : ",Show debug traces"
      _log DEBUG "Show app traces"
      shift 1
      set -x
      ;;
    -v|-vv|-vvv)
        : "[LEVEL],Set verbosity level"
        if [[ -n "${2:-}" ]] && _log_validate_level "${2:-}" 2>/dev/null; then
          APP_LOG_LEVEL="$2"
          shift 1
        elif [[ "$1" == "-v" ]]; then
          APP_LOG_LEVEL=INFO
        elif [[ "$1" == "-vv" ]]; then
          APP_LOG_LEVEL=DEBUG
        else
          _log DEBUG "Max logging enabled"          
          APP_LOG_LEVEL=TRACE
        fi
        shift 1
        _log DEBUG "Log level set to: $APP_LOG_LEVEL"
        ;;
    -*)
      _die 1 "Unknown option: $1"
      ;;
    *)
      args=("$@")
      shift $#

      # To enable greedy parsing
      # args+=( "$1" )
      # shift 1
      ;;
    esac
    # : "parse-opt-stop"
  done
}

cli() {
  # Init
  trap '_sh_trap_error $? ${LINENO} trap_exit 42' EXIT

  # Init app
  cli_init

  # Parse CLI flags
  clish_parse_opts cli "$@"
  set -- "${args[@]}"


  # Route commands before requirements
  local cmd=${1:-help}
  shift 1 || true
  case "$cmd" in
    init)
      cb_init "$@"
      _die 0
    ;;
    # init2)
    #   cb_init2 "$@"
    #   _die 0
    # ;;
    -h | --help | help | h)
      clish_help cli
      _die 0
    ;;
  esac

  cb_init_app
  cb_init_ctx

  # Check requirements
  cli_require

  # Dispatch subcommand
  clish_dispatch cli__ "$cmd" "$@" ||
    _die $? "Command '$cmd' returned error: $?"
}

cli "${@}"
